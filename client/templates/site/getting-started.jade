.container

  .jumbotron

    h1 Getting Started 
    p Find out how to use SocketStream to create Realtime Web Apps. 

  .row

    .col-md-3#guide
      ul.nav.nav-pills.nav-stacked
        h3 Guide
        li 
          a(href="#install-socketstream") Install SocketStream
        li 
          a(href="#creating-apps") Creating apps
        li
          a(href="#how-sockstream-apps-are-organised") How Socketstream apps are organised

    .col-md-7.col-md-offset-1

      .row#install-socketstream
        h2 Install SocketStream

        p SocketStream is built on top of Node.js, and is compatible with versions 0.8 and above. You can install it via npm.

        pre
          code npm install -g socketstream

        p The <code>-g</code> flag is passed to install SocketStream globally. This is so that you can run the <code>socketstream</code> command to generate new apps.

      .row#creating-apps
        h2 Creating apps

        p Creating an app in SocketStream is as simple as this:

        pre
          code socketstream new my_app

        p After you run this command, you will see the following output:

        pre
          code
            div.yellow Success! Created app 'my_app' with:
            div  ✓ Basic chat demo <span class="gray">(-m for minimal install)</span>
            div  ✓ Javascript example code <span class="gray">(-c if you prefer CoffeeScript)</span>
            div  ✓ Plain HTML for views <span class="gray">(-j if you prefer Jade)</span>
            div.yellow Next, run the following commands:
            div    cd my_app
            div    npm install
            div.yellow To start your app:
            div    npm start

        p If you look at the output, you will notice that the application has generated the basic chat demo (as hosted at <a href='http://demo.socketstream.com'>demo.socketstream.com</a>). You will also notice that there are flags to change what files the app will generate:
        br
        ul
          li <code><span class="gray">-m</span></code> Can be passed if you want an app that does not contain the chat demo app code.
          br 
          li <code><span class="gray">-c</span></code> Can be passed if you want an app with CoffeeScript files in place of JS files.
          br
          li <code><span class="gray">-j</span></code> Can be passed if you want an app with Jade templates instead of HTML templates.
        br
        p To pass these flags, specify them after the app name:
        pre
          code socketstream new my_other_app -m -c -j
        p After you have created your app, make sure to <code>cd</code> into your socketstream app, and run <code>npm install</code>. Once that is done, you can then run <code>npm start</code>. 

      .row#how-sockstream-apps-are-organised
        h2 How SocketStream apps are organised
        p If you take a look at the files and folders inside a new socketstream app, they look like this:
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-close &nbsp;
              b client
            li.glyphicon.glyphicon-folder-close &nbsp;
              b node_modules
            li.glyphicon.glyphicon-folder-close &nbsp;
              b server
            li.glyphicon.glyphicon-file &nbsp;app.js
            li.glyphicon.glyphicon-file &nbsp;package.json
            li.glyphicon.glyphicon-file &nbsp;README.md
        p SocketStream uses a small initial folder structure, structuring code based on whether it's client-side or server-side code. There is a node_modules folder and package.json file for module dependencies, and an app.js file which boots the SocketStream app. 
        p Let's look at the client folder in a bit more detail:
        h3 Client folder structure
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-open &nbsp;
              b client
            ul.appStructure
              li.glyphicon.glyphicon-folder-close &nbsp;
                b code
              li.glyphicon.glyphicon-folder-close &nbsp;
                b css
              li.glyphicon.glyphicon-folder-close &nbsp;
                b static
              li.glyphicon.glyphicon-folder-close &nbsp;
                b templates
              li.glyphicon.glyphicon-folder-close &nbsp;
                b views
        p Client-side files are organised into 5 folders:
        ul
          li <b>Code</b> stores front-end Javascript files, both the libraries that you want to use (e.g. jQuery, BackBone, D3) and the application code.
          li <b>CSS</b> stores CSS files
          li <b>Static</b> stores files that you want to allow public access to, such as images (e.g. /images/logo.png), font files, and other assets.
          li <b>Templates</b> stores client-side HTML templates that you want to render on the client
          li <b>Views stores</b> server-side HTML templates that you want to render on the initial server page load.
        p Within the code folder, you will notice that there are two folders, app and libs:
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-open &nbsp;
              b client
            ul.appStructure
              li.glyphicon.glyphicon-folder-open &nbsp;
                b code
              ul.appStructure
                li.glyphicon.glyphicon-folder-close &nbsp;
                  b app
                li.glyphicon.glyphicon-folder-close &nbsp;
                  b libs
        p This structure is suggested for helping to keep app-specific javascript files separate from 3rd-party javascript libraries like jQuery, Backbone, etc. You can change this structure if you wish. The same goes for the CSS folder:
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-open &nbsp;
              b client
            ul.appStructure
              li.glyphicon.glyphicon-folder-open &nbsp;
                b css
              ul.appStructure
                li.glyphicon.glyphicon-folder-close &nbsp;
                  b app
                li.glyphicon.glyphicon-folder-close &nbsp;
                  b libs
        p These folder structures are flexible, and the same goes for folders inside of the static folder:
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-open &nbsp;
              b client
            ul.appStructure
              li.glyphicon.glyphicon-folder-open &nbsp;
                b static
              ul.appStructure
                li.glyphicon.glyphicon-folder-close &nbsp;
                  b images
        p Files stores in this folder will be accessible in the web app from the root path, so an image file at <code>static/images/logo.png</code> will be accessible at <code>http://localhost:3000/images/logo.png</code>.
        h3 Server folder structure
        p Compared to the client folder structure, server-side files have a much more streamlined file structure:
        ul.appStructure
          li.glyphicon.glyphicon-folder-open &nbsp;
            b my_app
          ul.appStructure
            li.glyphicon.glyphicon-folder-open &nbsp;
              b server
            ul.appStructure
              li.glyphicon.glyphicon-folder-close &nbsp;
                b middleware
              li.glyphicon.glyphicon-folder-close &nbsp;
                b rpc
        p Client-side files are organised into 2 folders:
        ul
          li <b>Middleware</b> stores any files containing middleware that you want RPC requests to be able to use, such as for authentication.
          li <b>Rpc</b> stores files that expose RPC functions that the client can call to do things such as fetch data, authenticate the user, and transmit data.

